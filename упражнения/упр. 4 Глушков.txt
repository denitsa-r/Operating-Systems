Потоци -------------------------------------------

$find -L . -type l -> всички счупени симлинкове 

------------------------------------
|   text 
|                       2 - stderr
|   terminal <--------------------------------|
|                        1 - stdout           |
|    display <-------------------------|      |
|                                      |      |
|   keyboard--------------------------> Program 
|                   0 - stdin 
|
------------------------------------

0 - input 
1 - output 
2 - err

! ако на cat не подадем файл, който да прочете, то тя чете от stdin

$find -L . -type l 1>outputFile.txt 2>errorsFile.txt //пренасочва потоците към съответните файлове 

                &>someFile.txt // пренасочва output and error изходите към файла

<3 - /dev/null -> специален файл който нищо не ни изкарва, черна дупка 

Pipe ----------------------------------
use case : имаме програма, която печата на stdout, ама ние може да искаме да пренасочим тоя изход другаде. Примерно може да имаме файл с описани пътища към файлове и съответно бихме искали това нещо да го подадем като вход на някоя друга програма.
                program > file.txt 

            1 -stdout 
program --------------------->

program1 | program2 | program3

0     |---> 0      |--->0
1-----|     1 -----|    1
2           2           2

//изхода на едната програма се подава като вход на другата 

КОМАНДИ СВЪРЗАНИ С ТЕКСТ:
$cat <file> -> четем
$head
$tail
$wc -> брои някви неща за файловете 
$

извеждане на размер на файл - find -printf - тука има мн работи

s0600173@astero:~$ echo "baba" | wc -c
5
s0600173@astero:~$ echo "баба" | wc -c
9

-- разлика заради unicode в размера в байтове, но

s0600173@astero:~$ echo "baba" | wc -m
5
s0600173@astero:~$ echo "баба" | wc -m
5

-- еднакъв брой символи

$wc -c -> брои байтове
$wc -m  -> брои символи chars 

$cut -> много готина команда като имаме таблици, може да реже текст

-- brace expansion 
$touch f1 f2 f3
$touch f{1,2,3}

"" -> позволява brace expansion 
'' -> не позволява и отпечатва точно тва нещо 
--- основната разлика се появява при променливите 

brace expansion -> "", без
Subshell -> ""
globbing -> "", без 
ENV променливи -> "" -> те са локални за shell-a, subshella е отделен shell

как внедряваме аутпута на една команда в друга?
$<command> $(<new command>)

"-> дават ни да разширяваме всичко 
' vs " -> разлика в това как се отнасят към env променливи

$sort -> сортира някви работи, по подразбиране е по първото нещо дето намери, можем да му подадем и начин по който да сортира

$uniq -> връща ни уникалните редове от даден файл 

$comm -> compare, сравнява два файла, НО те трябва да са СОРТИРАНИ

subshella ни връща съдържанието от резултата на командата 

$comm <<какво да подам като вход>

$grep <pattern> <search> -> показва ни срещанията на патърна в търсещата директория
$xargs - разделяме съдържанието и го подаваме като аргументи 
$xargs -I -> замества текст 


2020-se-01
find ~ -type f -perm 644 -exec chmod {} g+w ';'
